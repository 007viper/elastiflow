filter {
    # Process Netflow v5 events.
    if [netflow][version] == 5 {
        mutate {
            add_field => {
                "[netflow][direction]" => "ingress"
                "[netflow][ip_version]" => "IPv4"
            }
            rename => {
                "[netflow][ipv4_src_addr]" => "[netflow][src_addr]"
                "[netflow][src_mask]" => "[netflow][src_mask_len]"
                "[netflow][l4_src_port]" => "[netflow][src_port]"
                "[netflow][ipv4_dst_addr]" => "[netflow][dst_addr]"
                "[netflow][dst_mask]" => "[netflow][dst_mask_len]"
                "[netflow][l4_dst_port]" => "[netflow][dst_port]"
                "[netflow][in_bytes]" => "[netflow][bytes]"
                "[netflow][in_pkts]" => "[netflow][packets]"
                "[netflow][ipv4_next_hop]" => "[netflow][next_hop]"
                "[netflow][src_tos]" => "[netflow][tos]"
            }
        }
    }
    # Process Netflow v9 events.
    else if [netflow][version] == 9 {
        if [netflow][ip_protocol_version] {
            mutate {
                add_field => { "[netflow][ip_version]" => "IPv%{[netflow][ip_protocol_version]}" }
            }
        }
        
        # Populate fields with IPv4 or IPv6 specific fields.
        if [netflow][ipv4_src_addr] or [netflow][ipv4_dst_addr] or [netflow][ip_protocol_version] == 4 {
            if [netflow][ipv4_src_addr] {
                mutate {
                    rename => { "[netflow][ipv4_src_addr]" => "[netflow][src_addr]" }
                }
            }
            if [netflow][src_mask] {
                mutate {
                    rename => { "[netflow][src_mask]" => "[netflow][src_mask_len]" }
                }
            }
            if [netflow][ipv4_dst_addr] {
                mutate {
                    rename => { "[netflow][ipv4_dst_addr]" => "[netflow][dst_addr]" }
                }
            }
            if [netflow][dst_mask] {
                mutate {
                    rename => { "[netflow][dst_mask]" => "[netflow][dst_mask_len]" }
                }
            }
            if [netflow][ipv4_next_hop] {
                mutate {
                    rename => { "[netflow][ipv4_next_hop]" => "[netflow][next_hop]" }
                }
            }
        } else if [netflow][ipv6_src_addr] or [netflow][ipv6_dst_addr] or [netflow][ip_protocol_version] == 6 {
            if [netflow][ipv6_src_addr] {
                mutate {
                    rename => { "[netflow][ipv6_src_addr]" => "[netflow][src_addr]" }
                }
            }
            if [netflow][ipv6_src_mask] {
                mutate {
                    rename => { "[netflow][ipv6_src_mask]" => "[netflow][src_mask_len]" }
                }
            }
            if [netflow][ipv6_dst_addr] {
                mutate {
                    rename => { "[netflow][ipv6_dst_addr]" => "[netflow][dst_addr]" }
                }
            }
            if [netflow][ipv6_dst_mask] {
                mutate {
                    rename => { "[netflow][ipv6_dst_mask]" => "[netflow][dst_mask_len]" }
                }
            }
            if [netflow][ipv6_next_hop] {
                mutate {
                    rename => { "[netflow][ipv6_next_hop]" => "[netflow][next_hop]" }
                }
            }
        } else {
            # Did not recognize IP version.
            mutate {
                add_tag => [ "__netflow_ip_version_not_recognized" ]
            }
        }
        
        # Populate flow direction (ingress/egress).
        if [netflow][direction] == 0 {
            mutate {
                replace => { "[netflow][direction]" => "ingress" }
            }
        } else if [netflow][direction] == 1 {
            mutate {
                replace => { "[netflow][direction]" => "egress" }
            }
        } else {
            mutate {
                add_tag => [ "__netflow_direction_not_recognized" ]
            }
        }

        # Populate source port.
        if [netflow][l4_src_port] {
            mutate {
                rename => { "[netflow][l4_src_port]" => "[netflow][src_port]" }
            }
        } else if [netflow][tcp_src_port] {
            mutate {
                rename => { "[netflow][tcp_src_port]" => "[netflow][src_port]" }
            }
        } else if [netflow][udp_src_port] {
            mutate {
                rename => { "[netflow][udp_src_port]" => "[netflow][src_port]" }
            }
        }

        # Populate destination port.
        if [netflow][l4_dst_port] {
            mutate {
                rename => { "[netflow][l4_dst_port]" => "[netflow][dst_port]" }
            }
        } else if [netflow][tcp_dst_port] {
            mutate {
                rename => { "[netflow][tcp_dst_port]" => "[netflow][dst_port]" }
            }
        } else if [netflow][udp_src_port] {
            mutate {
                rename => { "[netflow][udp_dst_port]" => "[netflow][dst_port]" }
            }
        }

        # Populate bytes transferred in the flow.
        if [netflow][in_bytes] {
            mutate {
                rename => { "[netflow][in_bytes]" => "[netflow][bytes]" }
            }
        } else if [netflow][out_bytes] {
            mutate {
                rename => { "[netflow][out_bytes]" => "[netflow][bytes]" }
            }
        } else if [netflow][in_permanent_bytes] {
            mutate {
                rename => { "[netflow][in_permanent_bytes]" => "[netflow][bytes]" }
            }
        }
        if [conn][bytes] {
            mutate {
                convert => { "[netflow][bytes]" => "integer" }
            }
        }
        
        # Populate packets transferred in the flow.
        if [netflow][in_pkts] {
            mutate {
                rename => { "[netflow][in_pkts]" => "[netflow][packets]" }
            }
        } else if [netflow][out_pkts] {
            mutate {
                rename => { "[netflow][out_pkts]" => "[netflow][packets]" }
            }
        } else if [netflow][in_permanent_pkts] {
            mutate {
                rename => { "[netflow][in_permanent_pkts]" => "[netflow][packets]" }
            }
        }
        if [netflow][packets] {
            mutate {
                convert => { "[netflow][packets]" => "integer" }
            }
        }

        # Populate source and destination MAC addresses if available.
        if [netflow][in_src_mac] {
            mutate {
                rename => { "[netflow][in_src_mac]" => "[netflow][src_mac]" }
            }
        } else if [netflow][out_src_mac] {
            mutate {
                rename => { "[netflow][out_src_mac]" => "[netflow][src_mac]" }
            }
        }
        if [netflow][in_dst_mac] {
            mutate {
                rename => { "[netflow][in_dst_mac]" => "[netflow][dst_mac]" }
            }
        } else if [netflow][out_dst_mac] {
            mutate {
                rename => { "[netflow][out_dst_mac]" => "[netflow][dst_mac]" }
            }
        }

        # Populate VLAN if available.
        if [netflow][src_vlan] {
            mutate {
                rename => { "[netflow][src_vlan]" => "[netflow][vlan]" }
            }
        } else if [netflow][dst_vlan] {
            mutate {
                rename => { "[netflow][dst_vlan]" => "[netflow][vlan]" }
            }
        }

        # Populate TOS if available.
        if [netflow][src_tos] {
            mutate {
                rename => { "[netflow][src_tos]" => "[netflow][tos]" }
            }
        }
    }

    # Replace protocol ID with well-known name.
    if [netflow][protocol] {
        if [netflow][protocol] == 6 {
            mutate {
                replace => { "[netflow][protocol]" => "TCP" }
            }
        } else if [netflow][protocol] == 17 {
            mutate {
                replace => { "[netflow][protocol]" => "UDP" }
            }
        } else if [netflow][protocol] == 1 {
            mutate {
                replace => { "[netflow][protocol]" => "ICMP" }
            }
        } else if [netflow][protocol] == 2 {
            mutate {
                replace => { "[netflow][protocol]" => "IGMP" }
            }
        } else if [netflow][protocol] == 33 {
            mutate {
                replace => { "[netflow][protocol]" => "DCCP" }
            }
        } else if [netflow][protocol] == 46 {
            mutate {
                replace => { "[netflow][protocol]" => "RSVP" }
            }
        } else if [netflow][protocol] == 47 {
            mutate {
                replace => { "[netflow][protocol]" => "GRE" }
            }
        } else if [netflow][protocol] == 88 {
            mutate {
                replace => { "[netflow][protocol]" => "EIGRP" }
            }
        } else if [netflow][protocol] == 89 {
            mutate {
                replace => { "[netflow][protocol]" => "OSPFIGP" }
            }
        } else if [netflow][protocol] == 132 {
            mutate {
                replace => { "[netflow][protocol]" => "SCTP" }
            }
        } else if [netflow][protocol] == 136 {
            mutate {
                replace => { "[netflow][protocol]" => "UDPLite" }
            }
        }
    }

    geoip {
        source => "[netflow][src_addr]"
        database => "${ELASTIFLOW_GEOIP_DB_PATH:/etc/logstash/geoipdbs}/GeoLite2-City.mmdb"
    }
    if "_geoip_lookup_failure" in [tags] {
        mutate {
            remove_tag => [ "_geoip_lookup_failure" ]
        }
        geoip {
            source => "[netflow][dst_addr]"
            database => "${ELASTIFLOW_GEOIP_DB_PATH:/etc/logstash/geoipdbs}/GeoLite2-City.mmdb"
        }
    }
}